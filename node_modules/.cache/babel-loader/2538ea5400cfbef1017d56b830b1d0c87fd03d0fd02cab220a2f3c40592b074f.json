{"ast":null,"code":"import _objectSpread from\"/home/hugo/Documents/4A/cyber/front_url_parser/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useRef}from\"react\";import{api}from\"../services/api\";import{jsx as _jsx}from\"react/jsx-runtime\";const WebSocketContext=/*#__PURE__*/createContext(undefined);export const WebSocketProvider=_ref=>{let{children}=_ref;const socketRef=useRef(null);const[userId,setUserId]=useState(null);const[connectedUsers,setConnectedUsers]=useState([]);const[userScores,setUserScores]=useState({});const[_,forceUpdate]=useState(0);const[shouldReposition,setShouldReposition]=useState(false);// Fonction pour récupérer les infos d'un utilisateur\nconst fetchUserInfo=async userId=>{try{const res=await api.get(\"auth/user/\".concat(userId));const userInfo=res.data;return{id:userInfo.id,username:userInfo.username,score:userInfo.score};}catch(error){console.error(\"Erreur lors de la récupération des infos utilisateur:\",error);}return null;};const connect=token=>{if(socketRef.current){socketRef.current.close();}const socket=new WebSocket(\"wss://projetdelamort.onrender.com/ws?token=\".concat(token));socket.onopen=()=>{console.log(\"WebSocket connecté\");};socket.onmessage=async event=>{try{const data=JSON.parse(event.data);if(data.type===\"user_connected\"&&data.user_id){setUserId(data.user_id);// Récupérer les infos du nouvel utilisateur connecté\nconst userInfo=await fetchUserInfo(data.user_id);if(userInfo){setConnectedUsers(prev=>{// Éviter les doublons\nconst exists=prev.some(user=>user.id===userInfo.id);return exists?prev:[...prev,userInfo];});// Mettre à jour les scores aussi\nsetUserScores(prev=>_objectSpread(_objectSpread({},prev),{},{[userInfo.id]:userInfo.score}));}}if(data.type===\"user_already_connected\"&&Array.isArray(data.users)){console.log(\"Liste des utilisateurs connectés :\",data.users);// Récupérer les infos complètes de tous les utilisateurs connectés\nconst userPromises=data.users.map(user=>fetchUserInfo(user.user_id));const usersInfo=await Promise.all(userPromises);const validUsers=usersInfo.filter(user=>user!==null);setConnectedUsers(validUsers);// Mettre à jour les scores\nconst scores={};validUsers.forEach(user=>{scores[user.id]=user.score;});setUserScores(scores);}if(data.type===\"user_disconnected\"&&data.user_id){console.log(\"❌ Utilisateur déconnecté :\",data.user_id);// Enlever l'utilisateur de la liste\nsetConnectedUsers(prev=>prev.filter(user=>user.id!==data.user_id));// Enlever son score\nsetUserScores(prev=>{const copy=_objectSpread({},prev);delete copy[data.user_id];return copy;});}if(data.type===\"score_update\"&&data.from&&typeof data.score===\"number\"){console.log(\"Mise à jour du score :\",data.score,\"de\",data.from);// Mettre à jour le score dans userScores\nsetUserScores(prev=>_objectSpread(_objectSpread({},prev),{},{[data.from]:data.score}));// Mettre à jour le score dans connectedUsers aussi\nsetConnectedUsers(prev=>prev.map(user=>user.id===data.from?_objectSpread(_objectSpread({},user),{},{score:data.score}):user));}}catch(e){console.log(\"Message reçu (non JSON) :\",event.data);}};socket.onerror=error=>{console.error(\"Erreur WebSocket :\",error);};socket.onclose=()=>{console.log(\"WebSocket fermé\");};socketRef.current=socket;forceUpdate(x=>x+1);};const disconnect=()=>{var _socketRef$current;(_socketRef$current=socketRef.current)===null||_socketRef$current===void 0?void 0:_socketRef$current.close();socketRef.current=null;setConnectedUsers([]);setUserScores({});forceUpdate(x=>x+1);};return/*#__PURE__*/_jsx(WebSocketContext.Provider,{value:{socket:socketRef.current,connect,disconnect,userId,connectedUsers,userScores},children:children});};export const useWebSocket=()=>{const context=useContext(WebSocketContext);if(!context)throw new Error(\"useWebSocket must be used within a WebSocketProvider\");return context;};","map":{"version":3,"names":["React","createContext","useContext","useState","useRef","api","jsx","_jsx","WebSocketContext","undefined","WebSocketProvider","_ref","children","socketRef","userId","setUserId","connectedUsers","setConnectedUsers","userScores","setUserScores","_","forceUpdate","shouldReposition","setShouldReposition","fetchUserInfo","res","get","concat","userInfo","data","id","username","score","error","console","connect","token","current","close","socket","WebSocket","onopen","log","onmessage","event","JSON","parse","type","user_id","prev","exists","some","user","_objectSpread","Array","isArray","users","userPromises","map","usersInfo","Promise","all","validUsers","filter","scores","forEach","copy","from","e","onerror","onclose","x","disconnect","_socketRef$current","Provider","value","useWebSocket","context","Error"],"sources":["/home/hugo/Documents/4A/cyber/front_url_parser/src/context/WebSocketContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useRef } from \"react\";\nimport { api } from \"../services/api\";\n\ntype User = {\n  id: string;\n  username: string;\n  score: number;\n};\n\ntype WebSocketContextType = {\n  socket: WebSocket | null;\n  connect: (token: string) => void;\n  disconnect: () => void;\n  userId: string | null;\n  connectedUsers: User[];\n  userScores: Record<string, number>;\n};\n\nconst WebSocketContext = createContext<WebSocketContextType | undefined>(\n  undefined\n);\n\nexport const WebSocketProvider = ({\n  children,\n}: {\n  children: React.ReactNode;\n}) => {\n  const socketRef = useRef<WebSocket | null>(null);\n  const [userId, setUserId] = useState<string | null>(null);\n  const [connectedUsers, setConnectedUsers] = useState<User[]>([]);\n  const [userScores, setUserScores] = useState<Record<string, number>>({});\n  const [_, forceUpdate] = useState(0);\n  const [shouldReposition, setShouldReposition] = useState(false);\n\n  // Fonction pour récupérer les infos d'un utilisateur\n  const fetchUserInfo = async (userId: string): Promise<User | null> => {\n    try {\n      const res = await api.get(`auth/user/${userId}`);\n      const userInfo = res.data;\n\n      return {\n        id: userInfo.id,\n        username: userInfo.username,\n        score: userInfo.score,\n      };\n    } catch (error) {\n      console.error(\n        \"Erreur lors de la récupération des infos utilisateur:\",\n        error\n      );\n    }\n    return null;\n  };\n\n  const connect = (token: string) => {\n    if (socketRef.current) {\n      socketRef.current.close();\n    }\n\n    const socket = new WebSocket(\n      `wss://projetdelamort.onrender.com/ws?token=${token}`\n    );\n\n    socket.onopen = () => {\n      console.log(\"WebSocket connecté\");\n    };\n\n    socket.onmessage = async (event) => {\n      try {\n        const data = JSON.parse(event.data);\n\n        if (data.type === \"user_connected\" && data.user_id) {\n          setUserId(data.user_id);\n\n          // Récupérer les infos du nouvel utilisateur connecté\n          const userInfo = await fetchUserInfo(data.user_id);\n          if (userInfo) {\n            setConnectedUsers((prev) => {\n              // Éviter les doublons\n              const exists = prev.some((user) => user.id === userInfo.id);\n              return exists ? prev : [...prev, userInfo];\n            });\n\n            // Mettre à jour les scores aussi\n            setUserScores((prev) => ({\n              ...prev,\n              [userInfo.id]: userInfo.score,\n            }));\n          }\n        }\n\n        if (\n          data.type === \"user_already_connected\" &&\n          Array.isArray(data.users)\n        ) {\n          console.log(\"Liste des utilisateurs connectés :\", data.users);\n\n          // Récupérer les infos complètes de tous les utilisateurs connectés\n          const userPromises = data.users.map((user: { user_id: string }) =>\n            fetchUserInfo(user.user_id)\n          );\n\n          const usersInfo = await Promise.all(userPromises);\n          const validUsers = usersInfo.filter(\n            (user): user is User => user !== null\n          );\n\n          setConnectedUsers(validUsers);\n\n          // Mettre à jour les scores\n          const scores: Record<string, number> = {};\n          validUsers.forEach((user) => {\n            scores[user.id] = user.score;\n          });\n          setUserScores(scores);\n        }\n\n        if (data.type === \"user_disconnected\" && data.user_id) {\n          console.log(\"❌ Utilisateur déconnecté :\", data.user_id);\n\n          // Enlever l'utilisateur de la liste\n          setConnectedUsers((prev) =>\n            prev.filter((user) => user.id !== data.user_id)\n          );\n\n          // Enlever son score\n          setUserScores((prev) => {\n            const copy = { ...prev };\n            delete copy[data.user_id];\n            return copy;\n          });\n        }\n\n        if (\n          data.type === \"score_update\" &&\n          data.from &&\n          typeof data.score === \"number\"\n        ) {\n          console.log(\"Mise à jour du score :\", data.score, \"de\", data.from);\n\n          // Mettre à jour le score dans userScores\n          setUserScores((prev) => ({\n            ...prev,\n            [data.from]: data.score,\n          }));\n\n          // Mettre à jour le score dans connectedUsers aussi\n          setConnectedUsers((prev) =>\n            prev.map((user) =>\n              user.id === data.from ? { ...user, score: data.score } : user\n            )\n          );\n        }\n      } catch (e) {\n        console.log(\"Message reçu (non JSON) :\", event.data);\n      }\n    };\n\n    socket.onerror = (error) => {\n      console.error(\"Erreur WebSocket :\", error);\n    };\n\n    socket.onclose = () => {\n      console.log(\"WebSocket fermé\");\n    };\n\n    socketRef.current = socket;\n    forceUpdate((x) => x + 1);\n  };\n\n  const disconnect = () => {\n    socketRef.current?.close();\n    socketRef.current = null;\n    setConnectedUsers([]);\n    setUserScores({});\n    forceUpdate((x) => x + 1);\n  };\n\n  return (\n    <WebSocketContext.Provider\n      value={{\n        socket: socketRef.current,\n        connect,\n        disconnect,\n        userId,\n        connectedUsers,\n        userScores,\n      }}\n    >\n      {children}\n    </WebSocketContext.Provider>\n  );\n};\n\nexport const useWebSocket = () => {\n  const context = useContext(WebSocketContext);\n  if (!context)\n    throw new Error(\"useWebSocket must be used within a WebSocketProvider\");\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}