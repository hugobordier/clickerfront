{"ast":null,"code":"import _objectSpread from\"/home/hugo/Documents/4A/cyber/front_url_parser/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useRef}from\"react\";import{api}from\"../services/api\";import{jsx as _jsx}from\"react/jsx-runtime\";const WebSocketContext=/*#__PURE__*/createContext(undefined);export const WebSocketProvider=_ref=>{let{children}=_ref;const socketRef=useRef(null);const[userId,setUserId]=useState(null);const[connectedUsers,setConnectedUsers]=useState([]);const[userScores,setUserScores]=useState({});const[_,forceUpdate]=useState(0);// Fonction pour récupérer les infos d'un utilisateur\nconst fetchUserInfo=async userId=>{try{const token=localStorage.getItem(\"token\");// Ajuste selon ton stockage\nconst res=await api.get(\"auth/users/\".concat(userId));const response=res.data;if(response.ok){const userInfo=await response.json();return{id:userInfo.id,username:userInfo.username,score:userInfo.score};}}catch(error){console.error(\"Erreur lors de la récupération des infos utilisateur:\",error);}return null;};const connect=token=>{if(socketRef.current){socketRef.current.close();}const socket=new WebSocket(\"wss://projetdelamort.onrender.com/ws?token=\".concat(token));socket.onopen=()=>{console.log(\"WebSocket connecté\");};socket.onmessage=async event=>{try{const data=JSON.parse(event.data);if(data.type===\"user_connected\"&&data.user_id){setUserId(data.user_id);// Récupérer les infos du nouvel utilisateur connecté\nconst userInfo=await fetchUserInfo(data.user_id);if(userInfo){setConnectedUsers(prev=>{// Éviter les doublons\nconst exists=prev.some(user=>user.id===userInfo.id);return exists?prev:[...prev,userInfo];});// Mettre à jour les scores aussi\nsetUserScores(prev=>_objectSpread(_objectSpread({},prev),{},{[userInfo.id]:userInfo.score}));}}if(data.type===\"user_already_connected\"&&Array.isArray(data.users)){console.log(\"Liste des utilisateurs connectés :\",data.users);// Récupérer les infos complètes de tous les utilisateurs connectés\nconst userPromises=data.users.map(user=>fetchUserInfo(user.user_id));const usersInfo=await Promise.all(userPromises);const validUsers=usersInfo.filter(user=>user!==null);setConnectedUsers(validUsers);// Mettre à jour les scores\nconst scores={};validUsers.forEach(user=>{scores[user.id]=user.score;});setUserScores(scores);}if(data.type===\"user_disconnected\"&&data.user_id){console.log(\"❌ Utilisateur déconnecté :\",data.user_id);// Enlever l'utilisateur de la liste\nsetConnectedUsers(prev=>prev.filter(user=>user.id!==data.user_id));// Enlever son score\nsetUserScores(prev=>{const copy=_objectSpread({},prev);delete copy[data.user_id];return copy;});}if(data.type===\"score_update\"&&data.from&&typeof data.score===\"number\"){console.log(\"Mise à jour du score :\",data.score,\"de\",data.from);// Mettre à jour le score dans userScores\nsetUserScores(prev=>_objectSpread(_objectSpread({},prev),{},{[data.from]:data.score}));// Mettre à jour le score dans connectedUsers aussi\nsetConnectedUsers(prev=>prev.map(user=>user.id===data.from?_objectSpread(_objectSpread({},user),{},{score:data.score}):user));}}catch(e){console.log(\"Message reçu (non JSON) :\",event.data);}};socket.onerror=error=>{console.error(\"Erreur WebSocket :\",error);};socket.onclose=()=>{console.log(\"WebSocket fermé\");};socketRef.current=socket;forceUpdate(x=>x+1);};const disconnect=()=>{var _socketRef$current;(_socketRef$current=socketRef.current)===null||_socketRef$current===void 0?void 0:_socketRef$current.close();socketRef.current=null;setConnectedUsers([]);setUserScores({});forceUpdate(x=>x+1);};return/*#__PURE__*/_jsx(WebSocketContext.Provider,{value:{socket:socketRef.current,connect,disconnect,userId,connectedUsers,userScores},children:children});};export const useWebSocket=()=>{const context=useContext(WebSocketContext);if(!context)throw new Error(\"useWebSocket must be used within a WebSocketProvider\");return context;};","map":{"version":3,"names":["React","createContext","useContext","useState","useRef","api","jsx","_jsx","WebSocketContext","undefined","WebSocketProvider","_ref","children","socketRef","userId","setUserId","connectedUsers","setConnectedUsers","userScores","setUserScores","_","forceUpdate","fetchUserInfo","token","localStorage","getItem","res","get","concat","response","data","ok","userInfo","json","id","username","score","error","console","connect","current","close","socket","WebSocket","onopen","log","onmessage","event","JSON","parse","type","user_id","prev","exists","some","user","_objectSpread","Array","isArray","users","userPromises","map","usersInfo","Promise","all","validUsers","filter","scores","forEach","copy","from","e","onerror","onclose","x","disconnect","_socketRef$current","Provider","value","useWebSocket","context","Error"],"sources":["/home/hugo/Documents/4A/cyber/front_url_parser/src/context/WebSocketContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useRef } from \"react\";\nimport { api } from \"../services/api\";\n\ntype User = {\n  id: string;\n  username: string;\n  score: number;\n};\n\ntype WebSocketContextType = {\n  socket: WebSocket | null;\n  connect: (token: string) => void;\n  disconnect: () => void;\n  userId: string | null;\n  connectedUsers: User[];\n  userScores: Record<string, number>;\n};\n\nconst WebSocketContext = createContext<WebSocketContextType | undefined>(\n  undefined\n);\n\nexport const WebSocketProvider = ({\n  children,\n}: {\n  children: React.ReactNode;\n}) => {\n  const socketRef = useRef<WebSocket | null>(null);\n  const [userId, setUserId] = useState<string | null>(null);\n  const [connectedUsers, setConnectedUsers] = useState<User[]>([]);\n  const [userScores, setUserScores] = useState<Record<string, number>>({});\n  const [_, forceUpdate] = useState(0);\n\n  // Fonction pour récupérer les infos d'un utilisateur\n  const fetchUserInfo = async (userId: string): Promise<User | null> => {\n    try {\n      const token = localStorage.getItem(\"token\"); // Ajuste selon ton stockage\n      const res = await api.get(`auth/users/${userId}`);\n      const response = res.data;\n\n      if (response.ok) {\n        const userInfo = await response.json();\n        return {\n          id: userInfo.id,\n          username: userInfo.username,\n          score: userInfo.score,\n        };\n      }\n    } catch (error) {\n      console.error(\n        \"Erreur lors de la récupération des infos utilisateur:\",\n        error\n      );\n    }\n    return null;\n  };\n\n  const connect = (token: string) => {\n    if (socketRef.current) {\n      socketRef.current.close();\n    }\n\n    const socket = new WebSocket(\n      `wss://projetdelamort.onrender.com/ws?token=${token}`\n    );\n\n    socket.onopen = () => {\n      console.log(\"WebSocket connecté\");\n    };\n\n    socket.onmessage = async (event) => {\n      try {\n        const data = JSON.parse(event.data);\n\n        if (data.type === \"user_connected\" && data.user_id) {\n          setUserId(data.user_id);\n\n          // Récupérer les infos du nouvel utilisateur connecté\n          const userInfo = await fetchUserInfo(data.user_id);\n          if (userInfo) {\n            setConnectedUsers((prev) => {\n              // Éviter les doublons\n              const exists = prev.some((user) => user.id === userInfo.id);\n              return exists ? prev : [...prev, userInfo];\n            });\n\n            // Mettre à jour les scores aussi\n            setUserScores((prev) => ({\n              ...prev,\n              [userInfo.id]: userInfo.score,\n            }));\n          }\n        }\n\n        if (\n          data.type === \"user_already_connected\" &&\n          Array.isArray(data.users)\n        ) {\n          console.log(\"Liste des utilisateurs connectés :\", data.users);\n\n          // Récupérer les infos complètes de tous les utilisateurs connectés\n          const userPromises = data.users.map((user: { user_id: string }) =>\n            fetchUserInfo(user.user_id)\n          );\n\n          const usersInfo = await Promise.all(userPromises);\n          const validUsers = usersInfo.filter(\n            (user): user is User => user !== null\n          );\n\n          setConnectedUsers(validUsers);\n\n          // Mettre à jour les scores\n          const scores: Record<string, number> = {};\n          validUsers.forEach((user) => {\n            scores[user.id] = user.score;\n          });\n          setUserScores(scores);\n        }\n\n        if (data.type === \"user_disconnected\" && data.user_id) {\n          console.log(\"❌ Utilisateur déconnecté :\", data.user_id);\n\n          // Enlever l'utilisateur de la liste\n          setConnectedUsers((prev) =>\n            prev.filter((user) => user.id !== data.user_id)\n          );\n\n          // Enlever son score\n          setUserScores((prev) => {\n            const copy = { ...prev };\n            delete copy[data.user_id];\n            return copy;\n          });\n        }\n\n        if (\n          data.type === \"score_update\" &&\n          data.from &&\n          typeof data.score === \"number\"\n        ) {\n          console.log(\"Mise à jour du score :\", data.score, \"de\", data.from);\n\n          // Mettre à jour le score dans userScores\n          setUserScores((prev) => ({\n            ...prev,\n            [data.from]: data.score,\n          }));\n\n          // Mettre à jour le score dans connectedUsers aussi\n          setConnectedUsers((prev) =>\n            prev.map((user) =>\n              user.id === data.from ? { ...user, score: data.score } : user\n            )\n          );\n        }\n      } catch (e) {\n        console.log(\"Message reçu (non JSON) :\", event.data);\n      }\n    };\n\n    socket.onerror = (error) => {\n      console.error(\"Erreur WebSocket :\", error);\n    };\n\n    socket.onclose = () => {\n      console.log(\"WebSocket fermé\");\n    };\n\n    socketRef.current = socket;\n    forceUpdate((x) => x + 1);\n  };\n\n  const disconnect = () => {\n    socketRef.current?.close();\n    socketRef.current = null;\n    setConnectedUsers([]);\n    setUserScores({});\n    forceUpdate((x) => x + 1);\n  };\n\n  return (\n    <WebSocketContext.Provider\n      value={{\n        socket: socketRef.current,\n        connect,\n        disconnect,\n        userId,\n        connectedUsers,\n        userScores,\n      }}\n    >\n      {children}\n    </WebSocketContext.Provider>\n  );\n};\n\nexport const useWebSocket = () => {\n  const context = useContext(WebSocketContext);\n  if (!context)\n    throw new Error(\"useWebSocket must be used within a WebSocketProvider\");\n  return context;\n};\n"],"mappings":"mIAAA,MAAO,CAAAA,KAAK,EAAIC,aAAa,CAAEC,UAAU,CAAEC,QAAQ,CAAEC,MAAM,KAAQ,OAAO,CAC1E,OAASC,GAAG,KAAQ,iBAAiB,CAAC,OAAAC,GAAA,IAAAC,IAAA,yBAiBtC,KAAM,CAAAC,gBAAgB,cAAGP,aAAa,CACpCQ,SACF,CAAC,CAED,MAAO,MAAM,CAAAC,iBAAiB,CAAGC,IAAA,EAI3B,IAJ4B,CAChCC,QAGF,CAAC,CAAAD,IAAA,CACC,KAAM,CAAAE,SAAS,CAAGT,MAAM,CAAmB,IAAI,CAAC,CAChD,KAAM,CAACU,MAAM,CAAEC,SAAS,CAAC,CAAGZ,QAAQ,CAAgB,IAAI,CAAC,CACzD,KAAM,CAACa,cAAc,CAAEC,iBAAiB,CAAC,CAAGd,QAAQ,CAAS,EAAE,CAAC,CAChE,KAAM,CAACe,UAAU,CAAEC,aAAa,CAAC,CAAGhB,QAAQ,CAAyB,CAAC,CAAC,CAAC,CACxE,KAAM,CAACiB,CAAC,CAAEC,WAAW,CAAC,CAAGlB,QAAQ,CAAC,CAAC,CAAC,CAEpC;AACA,KAAM,CAAAmB,aAAa,CAAG,KAAO,CAAAR,MAAc,EAA2B,CACpE,GAAI,CACF,KAAM,CAAAS,KAAK,CAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC,CAAE;AAC7C,KAAM,CAAAC,GAAG,CAAG,KAAM,CAAArB,GAAG,CAACsB,GAAG,eAAAC,MAAA,CAAed,MAAM,CAAE,CAAC,CACjD,KAAM,CAAAe,QAAQ,CAAGH,GAAG,CAACI,IAAI,CAEzB,GAAID,QAAQ,CAACE,EAAE,CAAE,CACf,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAH,QAAQ,CAACI,IAAI,CAAC,CAAC,CACtC,MAAO,CACLC,EAAE,CAAEF,QAAQ,CAACE,EAAE,CACfC,QAAQ,CAAEH,QAAQ,CAACG,QAAQ,CAC3BC,KAAK,CAAEJ,QAAQ,CAACI,KAClB,CAAC,CACH,CACF,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CACX,uDAAuD,CACvDA,KACF,CAAC,CACH,CACA,MAAO,KAAI,CACb,CAAC,CAED,KAAM,CAAAE,OAAO,CAAIhB,KAAa,EAAK,CACjC,GAAIV,SAAS,CAAC2B,OAAO,CAAE,CACrB3B,SAAS,CAAC2B,OAAO,CAACC,KAAK,CAAC,CAAC,CAC3B,CAEA,KAAM,CAAAC,MAAM,CAAG,GAAI,CAAAC,SAAS,+CAAAf,MAAA,CACoBL,KAAK,CACrD,CAAC,CAEDmB,MAAM,CAACE,MAAM,CAAG,IAAM,CACpBN,OAAO,CAACO,GAAG,CAAC,oBAAoB,CAAC,CACnC,CAAC,CAEDH,MAAM,CAACI,SAAS,CAAG,KAAO,CAAAC,KAAK,EAAK,CAClC,GAAI,CACF,KAAM,CAAAjB,IAAI,CAAGkB,IAAI,CAACC,KAAK,CAACF,KAAK,CAACjB,IAAI,CAAC,CAEnC,GAAIA,IAAI,CAACoB,IAAI,GAAK,gBAAgB,EAAIpB,IAAI,CAACqB,OAAO,CAAE,CAClDpC,SAAS,CAACe,IAAI,CAACqB,OAAO,CAAC,CAEvB;AACA,KAAM,CAAAnB,QAAQ,CAAG,KAAM,CAAAV,aAAa,CAACQ,IAAI,CAACqB,OAAO,CAAC,CAClD,GAAInB,QAAQ,CAAE,CACZf,iBAAiB,CAAEmC,IAAI,EAAK,CAC1B;AACA,KAAM,CAAAC,MAAM,CAAGD,IAAI,CAACE,IAAI,CAAEC,IAAI,EAAKA,IAAI,CAACrB,EAAE,GAAKF,QAAQ,CAACE,EAAE,CAAC,CAC3D,MAAO,CAAAmB,MAAM,CAAGD,IAAI,CAAG,CAAC,GAAGA,IAAI,CAAEpB,QAAQ,CAAC,CAC5C,CAAC,CAAC,CAEF;AACAb,aAAa,CAAEiC,IAAI,EAAAI,aAAA,CAAAA,aAAA,IACdJ,IAAI,MACP,CAACpB,QAAQ,CAACE,EAAE,EAAGF,QAAQ,CAACI,KAAK,EAC7B,CAAC,CACL,CACF,CAEA,GACEN,IAAI,CAACoB,IAAI,GAAK,wBAAwB,EACtCO,KAAK,CAACC,OAAO,CAAC5B,IAAI,CAAC6B,KAAK,CAAC,CACzB,CACArB,OAAO,CAACO,GAAG,CAAC,oCAAoC,CAAEf,IAAI,CAAC6B,KAAK,CAAC,CAE7D;AACA,KAAM,CAAAC,YAAY,CAAG9B,IAAI,CAAC6B,KAAK,CAACE,GAAG,CAAEN,IAAyB,EAC5DjC,aAAa,CAACiC,IAAI,CAACJ,OAAO,CAC5B,CAAC,CAED,KAAM,CAAAW,SAAS,CAAG,KAAM,CAAAC,OAAO,CAACC,GAAG,CAACJ,YAAY,CAAC,CACjD,KAAM,CAAAK,UAAU,CAAGH,SAAS,CAACI,MAAM,CAChCX,IAAI,EAAmBA,IAAI,GAAK,IACnC,CAAC,CAEDtC,iBAAiB,CAACgD,UAAU,CAAC,CAE7B;AACA,KAAM,CAAAE,MAA8B,CAAG,CAAC,CAAC,CACzCF,UAAU,CAACG,OAAO,CAAEb,IAAI,EAAK,CAC3BY,MAAM,CAACZ,IAAI,CAACrB,EAAE,CAAC,CAAGqB,IAAI,CAACnB,KAAK,CAC9B,CAAC,CAAC,CACFjB,aAAa,CAACgD,MAAM,CAAC,CACvB,CAEA,GAAIrC,IAAI,CAACoB,IAAI,GAAK,mBAAmB,EAAIpB,IAAI,CAACqB,OAAO,CAAE,CACrDb,OAAO,CAACO,GAAG,CAAC,4BAA4B,CAAEf,IAAI,CAACqB,OAAO,CAAC,CAEvD;AACAlC,iBAAiB,CAAEmC,IAAI,EACrBA,IAAI,CAACc,MAAM,CAAEX,IAAI,EAAKA,IAAI,CAACrB,EAAE,GAAKJ,IAAI,CAACqB,OAAO,CAChD,CAAC,CAED;AACAhC,aAAa,CAAEiC,IAAI,EAAK,CACtB,KAAM,CAAAiB,IAAI,CAAAb,aAAA,IAAQJ,IAAI,CAAE,CACxB,MAAO,CAAAiB,IAAI,CAACvC,IAAI,CAACqB,OAAO,CAAC,CACzB,MAAO,CAAAkB,IAAI,CACb,CAAC,CAAC,CACJ,CAEA,GACEvC,IAAI,CAACoB,IAAI,GAAK,cAAc,EAC5BpB,IAAI,CAACwC,IAAI,EACT,MAAO,CAAAxC,IAAI,CAACM,KAAK,GAAK,QAAQ,CAC9B,CACAE,OAAO,CAACO,GAAG,CAAC,wBAAwB,CAAEf,IAAI,CAACM,KAAK,CAAE,IAAI,CAAEN,IAAI,CAACwC,IAAI,CAAC,CAElE;AACAnD,aAAa,CAAEiC,IAAI,EAAAI,aAAA,CAAAA,aAAA,IACdJ,IAAI,MACP,CAACtB,IAAI,CAACwC,IAAI,EAAGxC,IAAI,CAACM,KAAK,EACvB,CAAC,CAEH;AACAnB,iBAAiB,CAAEmC,IAAI,EACrBA,IAAI,CAACS,GAAG,CAAEN,IAAI,EACZA,IAAI,CAACrB,EAAE,GAAKJ,IAAI,CAACwC,IAAI,CAAAd,aAAA,CAAAA,aAAA,IAAQD,IAAI,MAAEnB,KAAK,CAAEN,IAAI,CAACM,KAAK,GAAKmB,IAC3D,CACF,CAAC,CACH,CACF,CAAE,MAAOgB,CAAC,CAAE,CACVjC,OAAO,CAACO,GAAG,CAAC,2BAA2B,CAAEE,KAAK,CAACjB,IAAI,CAAC,CACtD,CACF,CAAC,CAEDY,MAAM,CAAC8B,OAAO,CAAInC,KAAK,EAAK,CAC1BC,OAAO,CAACD,KAAK,CAAC,oBAAoB,CAAEA,KAAK,CAAC,CAC5C,CAAC,CAEDK,MAAM,CAAC+B,OAAO,CAAG,IAAM,CACrBnC,OAAO,CAACO,GAAG,CAAC,iBAAiB,CAAC,CAChC,CAAC,CAEDhC,SAAS,CAAC2B,OAAO,CAAGE,MAAM,CAC1BrB,WAAW,CAAEqD,CAAC,EAAKA,CAAC,CAAG,CAAC,CAAC,CAC3B,CAAC,CAED,KAAM,CAAAC,UAAU,CAAGA,CAAA,GAAM,KAAAC,kBAAA,CACvB,CAAAA,kBAAA,CAAA/D,SAAS,CAAC2B,OAAO,UAAAoC,kBAAA,iBAAjBA,kBAAA,CAAmBnC,KAAK,CAAC,CAAC,CAC1B5B,SAAS,CAAC2B,OAAO,CAAG,IAAI,CACxBvB,iBAAiB,CAAC,EAAE,CAAC,CACrBE,aAAa,CAAC,CAAC,CAAC,CAAC,CACjBE,WAAW,CAAEqD,CAAC,EAAKA,CAAC,CAAG,CAAC,CAAC,CAC3B,CAAC,CAED,mBACEnE,IAAA,CAACC,gBAAgB,CAACqE,QAAQ,EACxBC,KAAK,CAAE,CACLpC,MAAM,CAAE7B,SAAS,CAAC2B,OAAO,CACzBD,OAAO,CACPoC,UAAU,CACV7D,MAAM,CACNE,cAAc,CACdE,UACF,CAAE,CAAAN,QAAA,CAEDA,QAAQ,CACgB,CAAC,CAEhC,CAAC,CAED,MAAO,MAAM,CAAAmE,YAAY,CAAGA,CAAA,GAAM,CAChC,KAAM,CAAAC,OAAO,CAAG9E,UAAU,CAACM,gBAAgB,CAAC,CAC5C,GAAI,CAACwE,OAAO,CACV,KAAM,IAAI,CAAAC,KAAK,CAAC,sDAAsD,CAAC,CACzE,MAAO,CAAAD,OAAO,CAChB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}