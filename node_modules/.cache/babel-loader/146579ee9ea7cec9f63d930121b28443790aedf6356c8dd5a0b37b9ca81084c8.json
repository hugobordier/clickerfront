{"ast":null,"code":"var _jsxFileName = \"/home/hugo/Documents/4A/cyber/front_url_parser/src/components/Pagejeu.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from \"react\";\nimport { incrementscore } from \"../services/servicesjeu\";\nimport { useWebSocket } from \"../context/WebSocketContext\";\nimport { checkmilestone } from \"../services/servicesjeu\";\nimport ModalECaptcha from \"./modalecaptcha\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Pagejeu = () => {\n  _s();\n  const {\n    socket,\n    userId,\n    connectedUsers\n  } = useWebSocket();\n  const containerRef = useRef(null); //ref vers le div contenant l'animation\n\n  const {\n    widthitems,\n    heightitems\n  } = {\n    widthitems: 200,\n    heightitems: 200\n  };\n  const {\n    widthtete,\n    heighttete\n  } = {\n    widthtete: 150,\n    heighttete: 150\n  };\n  const [startPos] = useState(() => getRandomxy(widthtete, heighttete));\n  const [pos, setPos] = useState(startPos);\n  const [dir, setDir] = useState({\n    dx: 2,\n    dy: 2\n  });\n  // const [staticimages,setstaticimages]= useState<{x:number;y:number,id:number,src:string}[]>([]);\n  const [staticimagescentre, setstaticimagescentre] = useState([]);\n  const [nextID, setNextID] = useState(0);\n  //\n  const [imgquibougent, setimgquibougent] = useState([]);\n  const [showCaptcha, setShowCaptcha] = useState(false);\n  const [captchaData, setCaptchaData] = useState(null);\n  useEffect(() => {\n    console.log(\"connectedUsers\", connectedUsers);\n    if (!connectedUsers || connectedUsers.length === 0) return;\n    setimgquibougent(connectedUsers.map(user => {\n      let pos;\n      do {\n        pos = getRandomxy(widthtete, heighttete);\n      } while (isOverlappingCenter(pos.x, pos.y));\n      return {\n        id: user.id,\n        pos,\n        dir: {\n          dx: 2,\n          dy: 2\n        },\n        src: `https://projetdelamort.onrender.com/assets/${user.id}.png`,\n        username: user.username,\n        score: user.score\n      };\n    }));\n  }, [connectedUsers]);\n  useEffect(() => {\n    let animationFrame;\n    const move = () => {\n      setimgquibougent(imgs => imgs.map(img => {\n        var _img$dir$dx, _img$dir, _img$dir$dy, _img$dir2, _img$dir$dx2, _img$dir3, _img$dir$dy2, _img$dir4;\n        const container = containerRef.current;\n        if (!container) return img;\n        let newX = img.pos.x + ((_img$dir$dx = (_img$dir = img.dir) === null || _img$dir === void 0 ? void 0 : _img$dir.dx) !== null && _img$dir$dx !== void 0 ? _img$dir$dx : 2);\n        let newY = img.pos.y + ((_img$dir$dy = (_img$dir2 = img.dir) === null || _img$dir2 === void 0 ? void 0 : _img$dir2.dy) !== null && _img$dir$dy !== void 0 ? _img$dir$dy : 2);\n        let newDx = (_img$dir$dx2 = (_img$dir3 = img.dir) === null || _img$dir3 === void 0 ? void 0 : _img$dir3.dx) !== null && _img$dir$dx2 !== void 0 ? _img$dir$dx2 : 2;\n        let newDy = (_img$dir$dy2 = (_img$dir4 = img.dir) === null || _img$dir4 === void 0 ? void 0 : _img$dir4.dy) !== null && _img$dir$dy2 !== void 0 ? _img$dir$dy2 : 2;\n\n        // rebond sur les bords du container\n        if (newX <= 0 || newX + widthtete >= container.offsetWidth) {\n          newDx *= -1;\n        }\n        if (newY <= 0 || newY + heighttete >= container.offsetHeight) {\n          newDy *= -1;\n        }\n\n        // collision avec l'image centrale\n        const Imagecentrex = container.offsetWidth / 2 - widthitems / 2;\n        const Imagecentrey = container.offsetHeight / 2 - heightitems / 2;\n        const rectImagemov = {\n          left: newX,\n          right: newX + widthtete,\n          top: newY,\n          bottom: newY + heighttete\n        };\n        const rectImagecenter = {\n          left: Imagecentrex,\n          right: Imagecentrex + widthitems,\n          top: Imagecentrey,\n          bottom: Imagecentrey + heightitems\n        };\n        const collision = rectImagemov.left < rectImagecenter.right && rectImagemov.right > rectImagecenter.left && rectImagemov.top < rectImagecenter.bottom && rectImagemov.bottom > rectImagecenter.top;\n        if (collision) {\n          const overlapX = Math.min(rectImagemov.right, rectImagecenter.right) - Math.max(rectImagemov.left, rectImagecenter.left);\n          const overlapY = Math.min(rectImagemov.bottom, rectImagecenter.bottom) - Math.max(rectImagemov.top, rectImagecenter.top);\n          if (overlapX < overlapY) {\n            newDx *= -1;\n          } else {\n            newDy *= -1;\n          }\n        }\n        return {\n          ...img,\n          pos: {\n            x: newX,\n            y: newY\n          },\n          dir: {\n            dx: newDx,\n            dy: newDy\n          }\n        };\n      }));\n      animationFrame = requestAnimationFrame(move);\n    };\n    animationFrame = requestAnimationFrame(move);\n    return () => cancelAnimationFrame(animationFrame);\n  }, []);\n  function isOverlappingCenter(x, y) {\n    const containerWidth = window.innerWidth;\n    const containerHeight = window.innerHeight;\n    const centerX = containerWidth / 2 - widthitems / 2;\n    const centerY = containerHeight / 2 - heightitems / 2;\n    const rectMov = {\n      left: x,\n      right: x + widthtete,\n      top: y,\n      bottom: y + heighttete\n    };\n    const rectCenter = {\n      left: centerX,\n      right: centerX + widthitems,\n      top: centerY,\n      bottom: centerY + heightitems\n    };\n    return rectMov.left < rectCenter.right && rectMov.right > rectCenter.left && rectMov.top < rectCenter.bottom && rectMov.bottom > rectCenter.top;\n  }\n  useEffect(() => {\n    const imageSources = [\"/images/coca.jpg\", \"/images/biere.png\", \"/images/mcsmart.jpg\", \"/images/bouteilles martini.png\", \"/images/burger.png\", \"/images/choppes bière.webp\", \"/images/frites.png\", \"/images/moscow mule.webp\", \"/images/pina colada.png\", \"/images/pisco sour.png\", \"/images/ti punch.png\", \"/images/verre de bière.webp\"];\n    const intervalle = setInterval(() => {\n      const randomimages = imageSources[Math.floor(Math.random() * imageSources.length)];\n      const newImage = {\n        id: nextID,\n        src: randomimages\n      };\n      setstaticimagescentre([newImage]);\n      setNextID(id => id + 1);\n    }, 1000);\n    return () => clearInterval(intervalle);\n  }, []);\n  function getRandomxy(width, height) {\n    const x = Math.floor(Math.random() * (window.innerWidth - width));\n    const y = Math.floor(Math.random() * (window.innerHeight - height));\n    return {\n      x,\n      y\n    };\n  }\n  const handleClick = async () => {\n    try {\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        const check = await checkmilestone();\n        if (check.requires_verification) {\n          setCaptchaData(check);\n          setShowCaptcha(true);\n          return;\n        }\n        socket.send(JSON.stringify({\n          type: \"click\",\n          data: {\n            x: pos.x,\n            y: pos.y\n          }\n        }));\n        const response = await incrementscore();\n        const newScore = response.new_score;\n        if (userId) {\n          setimgquibougent(prev => prev.map(img => img.id === userId ? {\n            ...img,\n            score: newScore\n          } : img));\n        }\n        console.log(\"Score incrémenté:\", response);\n      } else {\n        console.error(\"pas connecté au websocket\");\n      }\n    } catch (error) {\n      console.error(\"Erreur lors du clic sur l'image:\", error);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    style: {\n      width: \"100vw\",\n      height: \"100vh\",\n      backgroundColor: \"#000\",\n      overflow: \"hidden\",\n      position: \"relative\"\n    },\n    children: [imgquibougent.map(img => /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"relative\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"img\", {\n        src: img.src,\n        alt: `user ${img.username}`,\n        style: {\n          position: \"absolute\",\n          top: img.pos.y,\n          left: img.pos.x,\n          width: widthtete,\n          height: heighttete,\n          zIndex: 1\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: \"absolute\",\n          top: img.pos.y - 25,\n          left: img.pos.x,\n          color: \"white\",\n          fontSize: \"12px\",\n          backgroundColor: \"rgba(0,0,0,0.7)\",\n          padding: \"2px 4px\",\n          borderRadius: \"3px\",\n          zIndex: 2,\n          whiteSpace: \"nowrap\"\n        },\n        children: [img.username, \": \", img.score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 257,\n        columnNumber: 11\n      }, this)]\n    }, img.id, true, {\n      fileName: _jsxFileName,\n      lineNumber: 243,\n      columnNumber: 9\n    }, this)), staticimagescentre.map(img => /*#__PURE__*/_jsxDEV(\"img\", {\n      src: img.src,\n      onClick: handleClick,\n      style: {\n        position: \"absolute\",\n        top: `calc(50% - ${heightitems / 2}px)`,\n        left: `calc(50% - ${widthitems / 2}px)`,\n        width: widthitems,\n        height: heightitems,\n        cursor: \"pointer\",\n        zIndex: 10\n      }\n    }, img.id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 277,\n      columnNumber: 9\n    }, this)), showCaptcha && /*#__PURE__*/_jsxDEV(ModalECaptcha, {\n      onClose: () => setShowCaptcha(false),\n      captchaData: captchaData\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 294,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 232,\n    columnNumber: 5\n  }, this);\n};\n_s(Pagejeu, \"sQT/bjsCxNOScAFsq3+K2Vq+LzE=\", false, function () {\n  return [useWebSocket];\n});\n_c = Pagejeu;\nexport default Pagejeu;\nvar _c;\n$RefreshReg$(_c, \"Pagejeu\");","map":{"version":3,"names":["React","useRef","useEffect","useState","incrementscore","useWebSocket","checkmilestone","ModalECaptcha","jsxDEV","_jsxDEV","Pagejeu","_s","socket","userId","connectedUsers","containerRef","widthitems","heightitems","widthtete","heighttete","startPos","getRandomxy","pos","setPos","dir","setDir","dx","dy","staticimagescentre","setstaticimagescentre","nextID","setNextID","imgquibougent","setimgquibougent","showCaptcha","setShowCaptcha","captchaData","setCaptchaData","console","log","length","map","user","isOverlappingCenter","x","y","id","src","username","score","animationFrame","move","imgs","img","_img$dir$dx","_img$dir","_img$dir$dy","_img$dir2","_img$dir$dx2","_img$dir3","_img$dir$dy2","_img$dir4","container","current","newX","newY","newDx","newDy","offsetWidth","offsetHeight","Imagecentrex","Imagecentrey","rectImagemov","left","right","top","bottom","rectImagecenter","collision","overlapX","Math","min","max","overlapY","requestAnimationFrame","cancelAnimationFrame","containerWidth","window","innerWidth","containerHeight","innerHeight","centerX","centerY","rectMov","rectCenter","imageSources","intervalle","setInterval","randomimages","floor","random","newImage","clearInterval","width","height","handleClick","readyState","WebSocket","OPEN","check","requires_verification","send","JSON","stringify","type","data","response","newScore","new_score","prev","error","ref","style","backgroundColor","overflow","position","children","alt","zIndex","fileName","_jsxFileName","lineNumber","columnNumber","color","fontSize","padding","borderRadius","whiteSpace","onClick","cursor","onClose","_c","$RefreshReg$"],"sources":["/home/hugo/Documents/4A/cyber/front_url_parser/src/components/Pagejeu.tsx"],"sourcesContent":["import React, { useRef, useEffect, useState, use } from \"react\";\nimport { incrementscore } from \"../services/servicesjeu\";\nimport { useWebSocket } from \"../context/WebSocketContext\";\nimport { checkmilestone } from \"../services/servicesjeu\";\nimport ModalECaptcha from \"./modalecaptcha\";\n\nconst Pagejeu = () => {\n  const { socket, userId, connectedUsers } = useWebSocket();\n  const containerRef = useRef<HTMLDivElement>(null); //ref vers le div contenant l'animation\n\n  const { widthitems, heightitems } = { widthitems: 200, heightitems: 200 };\n  const { widthtete, heighttete } = { widthtete: 150, heighttete: 150 };\n\n  const [startPos] = useState(() => getRandomxy(widthtete, heighttete));\n  const [pos, setPos] = useState(startPos);\n  const [dir, setDir] = useState({ dx: 2, dy: 2 });\n  // const [staticimages,setstaticimages]= useState<{x:number;y:number,id:number,src:string}[]>([]);\n  const [staticimagescentre, setstaticimagescentre] = useState<\n    { id: number; src: string }[]\n  >([]);\n  const [nextID, setNextID] = useState(0);\n  //\n  const [imgquibougent, setimgquibougent] = useState<\n    {\n      id: string;\n      pos: { x: number; y: number };\n      dir: { dx: number; dy: number };\n      src: string;\n      username: string;\n      score: number;\n    }[]\n  >([]);\n\n  const [showCaptcha, setShowCaptcha] = useState(false);\n  const [captchaData, setCaptchaData] = useState<any>(null);\n\n  useEffect(() => {\n    console.log(\"connectedUsers\", connectedUsers);\n\n    if (!connectedUsers || connectedUsers.length === 0) return;\n\n    setimgquibougent(\n      connectedUsers.map((user) => {\n        let pos;\n        do {\n          pos = getRandomxy(widthtete, heighttete);\n        } while (isOverlappingCenter(pos.x, pos.y));\n        return {\n          id: user.id,\n          pos,\n          dir: { dx: 2, dy: 2 },\n          src: `https://projetdelamort.onrender.com/assets/${user.id}.png`,\n          username: user.username,\n          score: user.score,\n        };\n      })\n    );\n  }, [connectedUsers]);\n\n  useEffect(() => {\n    let animationFrame: number;\n\n    const move = () => {\n      setimgquibougent((imgs) =>\n        imgs.map((img) => {\n          const container = containerRef.current;\n          if (!container) return img;\n\n          let newX = img.pos.x + (img.dir?.dx ?? 2);\n          let newY = img.pos.y + (img.dir?.dy ?? 2);\n          let newDx = img.dir?.dx ?? 2;\n          let newDy = img.dir?.dy ?? 2;\n\n          // rebond sur les bords du container\n          if (newX <= 0 || newX + widthtete >= container.offsetWidth) {\n            newDx *= -1;\n          }\n          if (newY <= 0 || newY + heighttete >= container.offsetHeight) {\n            newDy *= -1;\n          }\n\n          // collision avec l'image centrale\n          const Imagecentrex = container.offsetWidth / 2 - widthitems / 2;\n          const Imagecentrey = container.offsetHeight / 2 - heightitems / 2;\n          const rectImagemov = {\n            left: newX,\n            right: newX + widthtete,\n            top: newY,\n            bottom: newY + heighttete,\n          };\n          const rectImagecenter = {\n            left: Imagecentrex,\n            right: Imagecentrex + widthitems,\n            top: Imagecentrey,\n            bottom: Imagecentrey + heightitems,\n          };\n          const collision =\n            rectImagemov.left < rectImagecenter.right &&\n            rectImagemov.right > rectImagecenter.left &&\n            rectImagemov.top < rectImagecenter.bottom &&\n            rectImagemov.bottom > rectImagecenter.top;\n\n          if (collision) {\n            const overlapX =\n              Math.min(rectImagemov.right, rectImagecenter.right) -\n              Math.max(rectImagemov.left, rectImagecenter.left);\n            const overlapY =\n              Math.min(rectImagemov.bottom, rectImagecenter.bottom) -\n              Math.max(rectImagemov.top, rectImagecenter.top);\n\n            if (overlapX < overlapY) {\n              newDx *= -1;\n            } else {\n              newDy *= -1;\n            }\n          }\n\n          return {\n            ...img,\n            pos: { x: newX, y: newY },\n            dir: { dx: newDx, dy: newDy },\n          };\n        })\n      );\n      animationFrame = requestAnimationFrame(move);\n    };\n\n    animationFrame = requestAnimationFrame(move);\n    return () => cancelAnimationFrame(animationFrame);\n  }, []);\n\n  function isOverlappingCenter(x: number, y: number) {\n    const containerWidth = window.innerWidth;\n    const containerHeight = window.innerHeight;\n    const centerX = containerWidth / 2 - widthitems / 2;\n    const centerY = containerHeight / 2 - heightitems / 2;\n\n    const rectMov = {\n      left: x,\n      right: x + widthtete,\n      top: y,\n      bottom: y + heighttete,\n    };\n    const rectCenter = {\n      left: centerX,\n      right: centerX + widthitems,\n      top: centerY,\n      bottom: centerY + heightitems,\n    };\n\n    return (\n      rectMov.left < rectCenter.right &&\n      rectMov.right > rectCenter.left &&\n      rectMov.top < rectCenter.bottom &&\n      rectMov.bottom > rectCenter.top\n    );\n  }\n\n  useEffect(() => {\n    const imageSources = [\n      \"/images/coca.jpg\",\n      \"/images/biere.png\",\n      \"/images/mcsmart.jpg\",\n      \"/images/bouteilles martini.png\",\n      \"/images/burger.png\",\n      \"/images/choppes bière.webp\",\n      \"/images/frites.png\",\n      \"/images/moscow mule.webp\",\n      \"/images/pina colada.png\",\n      \"/images/pisco sour.png\",\n      \"/images/ti punch.png\",\n      \"/images/verre de bière.webp\",\n    ];\n\n    const intervalle = setInterval(() => {\n      const randomimages =\n        imageSources[Math.floor(Math.random() * imageSources.length)];\n\n      const newImage = {\n        id: nextID,\n        src: randomimages,\n      };\n\n      setstaticimagescentre([newImage]);\n      setNextID((id) => id + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalle);\n  }, []);\n\n  function getRandomxy(width: number, height: number) {\n    const x = Math.floor(Math.random() * (window.innerWidth - width));\n    const y = Math.floor(Math.random() * (window.innerHeight - height));\n    return { x, y };\n  }\n\n  const handleClick = async () => {\n    try {\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        const check = await checkmilestone();\n        if (check.requires_verification) {\n          setCaptchaData(check);\n          setShowCaptcha(true);\n          return;\n        }\n\n        socket.send(\n          JSON.stringify({ type: \"click\", data: { x: pos.x, y: pos.y } })\n        );\n\n        const response = await incrementscore();\n        const newScore = response.new_score;\n\n        if (userId) {\n          setimgquibougent((prev) =>\n            prev.map((img) =>\n              img.id === userId ? { ...img, score: newScore } : img\n            )\n          );\n        }\n\n        console.log(\"Score incrémenté:\", response);\n      } else {\n        console.error(\"pas connecté au websocket\");\n      }\n    } catch (error) {\n      console.error(\"Erreur lors du clic sur l'image:\", error);\n    }\n  };\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        width: \"100vw\",\n        height: \"100vh\",\n        backgroundColor: \"#000\",\n        overflow: \"hidden\",\n        position: \"relative\",\n      }}\n    >\n      {imgquibougent.map((img) => (\n        <div key={img.id} style={{ position: \"relative\" }}>\n          <img\n            src={img.src}\n            alt={`user ${img.username}`}\n            style={{\n              position: \"absolute\",\n              top: img.pos.y,\n              left: img.pos.x,\n              width: widthtete,\n              height: heighttete,\n              zIndex: 1,\n            }}\n          />\n          {/* Affichage optionnel du nom et score */}\n          <div\n            style={{\n              position: \"absolute\",\n              top: img.pos.y - 25,\n              left: img.pos.x,\n              color: \"white\",\n              fontSize: \"12px\",\n              backgroundColor: \"rgba(0,0,0,0.7)\",\n              padding: \"2px 4px\",\n              borderRadius: \"3px\",\n              zIndex: 2,\n              whiteSpace: \"nowrap\",\n            }}\n          >\n            {img.username}: {img.score}\n          </div>\n        </div>\n      ))}\n\n      {staticimagescentre.map((img) => (\n        <img\n          key={img.id}\n          src={img.src}\n          onClick={handleClick}\n          style={{\n            position: \"absolute\",\n            top: `calc(50% - ${heightitems / 2}px)`,\n            left: `calc(50% - ${widthitems / 2}px)`,\n            width: widthitems,\n            height: heightitems,\n            cursor: \"pointer\",\n            zIndex: 10,\n          }}\n        />\n      ))}\n\n      {showCaptcha && (\n        <ModalECaptcha\n          onClose={() => setShowCaptcha(false)}\n          captchaData={captchaData}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default Pagejeu;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}