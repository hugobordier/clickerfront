{"ast":null,"code":"var _jsxFileName = \"/home/hugo/Documents/4A/cyber/front_url_parser/src/context/WebSocketContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useRef } from \"react\";\nimport { api } from \"../services/api\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WebSocketContext = /*#__PURE__*/createContext(undefined);\nexport const WebSocketProvider = ({\n  children\n}) => {\n  _s();\n  const socketRef = useRef(null);\n  const [userId, setUserId] = useState(null);\n  const [connectedUsers, setConnectedUsers] = useState([]);\n  const [userScores, setUserScores] = useState({});\n  const [_, forceUpdate] = useState(0);\n  const [shouldReposition, setShouldReposition] = useState(false);\n\n  // Fonction pour récupérer les infos d'un utilisateur\n  const fetchUserInfo = async userId => {\n    try {\n      const res = await api.get(`auth/user/${userId}`);\n      const userInfo = res.data;\n      return {\n        id: userInfo.id,\n        username: userInfo.username,\n        score: userInfo.score\n      };\n    } catch (error) {\n      console.error(\"Erreur lors de la récupération des infos utilisateur:\", error);\n    }\n    return null;\n  };\n  const connect = token => {\n    if (socketRef.current) {\n      socketRef.current.close();\n    }\n    const socket = new WebSocket(`wss://projetdelamort.onrender.com/ws?token=${token}`);\n    socket.onopen = () => {\n      console.log(\"WebSocket connecté\");\n    };\n    socket.onmessage = async event => {\n      try {\n        const data = JSON.parse(event.data);\n        if (data.type === \"user_connected\" && data.user_id) {\n          setUserId(data.user_id);\n\n          // Récupérer les infos du nouvel utilisateur connecté\n          const userInfo = await fetchUserInfo(data.user_id);\n          if (userInfo) {\n            setConnectedUsers(prev => {\n              // Éviter les doublons\n              const exists = prev.some(user => user.id === userInfo.id);\n              return exists ? prev : [...prev, userInfo];\n            });\n\n            // Mettre à jour les scores aussi\n            setUserScores(prev => ({\n              ...prev,\n              [userInfo.id]: userInfo.score\n            }));\n          }\n        }\n        if (data.type === \"user_already_connected\" && Array.isArray(data.users)) {\n          console.log(\"Liste des utilisateurs connectés :\", data.users);\n\n          // Récupérer les infos complètes de tous les utilisateurs connectés\n          const userPromises = data.users.map(user => fetchUserInfo(user.user_id));\n          const usersInfo = await Promise.all(userPromises);\n          const validUsers = usersInfo.filter(user => user !== null);\n          setConnectedUsers(validUsers);\n\n          // Mettre à jour les scores\n          const scores = {};\n          validUsers.forEach(user => {\n            scores[user.id] = user.score;\n          });\n          setUserScores(scores);\n        }\n        if (data.type === \"user_disconnected\" && data.user_id) {\n          console.log(\"❌ Utilisateur déconnecté :\", data.user_id);\n\n          // Enlever l'utilisateur de la liste\n          setConnectedUsers(prev => prev.filter(user => user.id !== data.user_id));\n\n          // Enlever son score\n          setUserScores(prev => {\n            const copy = {\n              ...prev\n            };\n            delete copy[data.user_id];\n            return copy;\n          });\n        }\n        if (data.type === \"score_update\" && data.from && typeof data.score === \"number\") {\n          console.log(\"Mise à jour du score :\", data.score, \"de\", data.from);\n          setUserScores(prev => ({\n            ...prev,\n            [data.from]: data.score\n          }));\n          setConnectedUsers(prev => prev.map(user => user.id === data.from ? {\n            ...user,\n            score: data.score\n          } : user));\n          setShouldReposition(true); // <- C’est ça qui va déclencher le repositionnement aléatoire\n        }\n      } catch (e) {\n        console.log(\"Message reçu (non JSON) :\", event.data);\n      }\n    };\n    socket.onerror = error => {\n      console.error(\"Erreur WebSocket :\", error);\n    };\n    socket.onclose = () => {\n      console.log(\"WebSocket fermé\");\n    };\n    socketRef.current = socket;\n    forceUpdate(x => x + 1);\n  };\n  const disconnect = () => {\n    var _socketRef$current;\n    (_socketRef$current = socketRef.current) === null || _socketRef$current === void 0 ? void 0 : _socketRef$current.close();\n    socketRef.current = null;\n    setConnectedUsers([]);\n    setUserScores({});\n    forceUpdate(x => x + 1);\n  };\n  return /*#__PURE__*/_jsxDEV(WebSocketContext.Provider, {\n    value: {\n      socket: socketRef.current,\n      connect,\n      disconnect,\n      userId,\n      connectedUsers,\n      userScores,\n      shouldReposition,\n      setShouldReposition\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 182,\n    columnNumber: 5\n  }, this);\n};\n_s(WebSocketProvider, \"9J8N8DbWNNIyr3vvwCw66mvTtLM=\");\n_c = WebSocketProvider;\nexport const useWebSocket = () => {\n  _s2();\n  const context = useContext(WebSocketContext);\n  if (!context) throw new Error(\"useWebSocket must be used within a WebSocketProvider\");\n  return context;\n};\n_s2(useWebSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WebSocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useRef","api","jsxDEV","_jsxDEV","WebSocketContext","undefined","WebSocketProvider","children","_s","socketRef","userId","setUserId","connectedUsers","setConnectedUsers","userScores","setUserScores","_","forceUpdate","shouldReposition","setShouldReposition","fetchUserInfo","res","get","userInfo","data","id","username","score","error","console","connect","token","current","close","socket","WebSocket","onopen","log","onmessage","event","JSON","parse","type","user_id","prev","exists","some","user","Array","isArray","users","userPromises","map","usersInfo","Promise","all","validUsers","filter","scores","forEach","copy","from","e","onerror","onclose","x","disconnect","_socketRef$current","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWebSocket","_s2","context","Error","$RefreshReg$"],"sources":["/home/hugo/Documents/4A/cyber/front_url_parser/src/context/WebSocketContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useRef } from \"react\";\nimport { api } from \"../services/api\";\n\ntype User = {\n  id: string;\n  username: string;\n  score: number;\n};\n\ntype WebSocketContextType = {\n  socket: WebSocket | null;\n  connect: (token: string) => void;\n  disconnect: () => void;\n  userId: string | null;\n  connectedUsers: User[];\n  userScores: Record<string, number>;\n  shouldReposition: boolean;\n  setShouldReposition: React.Dispatch<React.SetStateAction<boolean>>;\n};\n\nconst WebSocketContext = createContext<WebSocketContextType | undefined>(\n  undefined\n);\n\nexport const WebSocketProvider = ({\n  children,\n}: {\n  children: React.ReactNode;\n}) => {\n  const socketRef = useRef<WebSocket | null>(null);\n  const [userId, setUserId] = useState<string | null>(null);\n  const [connectedUsers, setConnectedUsers] = useState<User[]>([]);\n  const [userScores, setUserScores] = useState<Record<string, number>>({});\n  const [_, forceUpdate] = useState(0);\n  const [shouldReposition, setShouldReposition] = useState(false);\n\n  // Fonction pour récupérer les infos d'un utilisateur\n  const fetchUserInfo = async (userId: string): Promise<User | null> => {\n    try {\n      const res = await api.get(`auth/user/${userId}`);\n      const userInfo = res.data;\n\n      return {\n        id: userInfo.id,\n        username: userInfo.username,\n        score: userInfo.score,\n      };\n    } catch (error) {\n      console.error(\n        \"Erreur lors de la récupération des infos utilisateur:\",\n        error\n      );\n    }\n    return null;\n  };\n\n  const connect = (token: string) => {\n    if (socketRef.current) {\n      socketRef.current.close();\n    }\n\n    const socket = new WebSocket(\n      `wss://projetdelamort.onrender.com/ws?token=${token}`\n    );\n\n    socket.onopen = () => {\n      console.log(\"WebSocket connecté\");\n    };\n\n    socket.onmessage = async (event) => {\n      try {\n        const data = JSON.parse(event.data);\n\n        if (data.type === \"user_connected\" && data.user_id) {\n          setUserId(data.user_id);\n\n          // Récupérer les infos du nouvel utilisateur connecté\n          const userInfo = await fetchUserInfo(data.user_id);\n          if (userInfo) {\n            setConnectedUsers((prev) => {\n              // Éviter les doublons\n              const exists = prev.some((user) => user.id === userInfo.id);\n              return exists ? prev : [...prev, userInfo];\n            });\n\n            // Mettre à jour les scores aussi\n            setUserScores((prev) => ({\n              ...prev,\n              [userInfo.id]: userInfo.score,\n            }));\n          }\n        }\n\n        if (\n          data.type === \"user_already_connected\" &&\n          Array.isArray(data.users)\n        ) {\n          console.log(\"Liste des utilisateurs connectés :\", data.users);\n\n          // Récupérer les infos complètes de tous les utilisateurs connectés\n          const userPromises = data.users.map((user: { user_id: string }) =>\n            fetchUserInfo(user.user_id)\n          );\n\n          const usersInfo = await Promise.all(userPromises);\n          const validUsers = usersInfo.filter(\n            (user): user is User => user !== null\n          );\n\n          setConnectedUsers(validUsers);\n\n          // Mettre à jour les scores\n          const scores: Record<string, number> = {};\n          validUsers.forEach((user) => {\n            scores[user.id] = user.score;\n          });\n          setUserScores(scores);\n        }\n\n        if (data.type === \"user_disconnected\" && data.user_id) {\n          console.log(\"❌ Utilisateur déconnecté :\", data.user_id);\n\n          // Enlever l'utilisateur de la liste\n          setConnectedUsers((prev) =>\n            prev.filter((user) => user.id !== data.user_id)\n          );\n\n          // Enlever son score\n          setUserScores((prev) => {\n            const copy = { ...prev };\n            delete copy[data.user_id];\n            return copy;\n          });\n        }\n\n        if (\n          data.type === \"score_update\" &&\n          data.from &&\n          typeof data.score === \"number\"\n        ) {\n          console.log(\"Mise à jour du score :\", data.score, \"de\", data.from);\n\n          setUserScores((prev) => ({\n            ...prev,\n            [data.from]: data.score,\n          }));\n\n          setConnectedUsers((prev) =>\n            prev.map((user) =>\n              user.id === data.from ? { ...user, score: data.score } : user\n            )\n          );\n\n          setShouldReposition(true); // <- C’est ça qui va déclencher le repositionnement aléatoire\n        }\n      } catch (e) {\n        console.log(\"Message reçu (non JSON) :\", event.data);\n      }\n    };\n\n    socket.onerror = (error) => {\n      console.error(\"Erreur WebSocket :\", error);\n    };\n\n    socket.onclose = () => {\n      console.log(\"WebSocket fermé\");\n    };\n\n    socketRef.current = socket;\n    forceUpdate((x) => x + 1);\n  };\n\n  const disconnect = () => {\n    socketRef.current?.close();\n    socketRef.current = null;\n    setConnectedUsers([]);\n    setUserScores({});\n    forceUpdate((x) => x + 1);\n  };\n\n  return (\n    <WebSocketContext.Provider\n      value={{\n        socket: socketRef.current,\n        connect,\n        disconnect,\n        userId,\n        connectedUsers,\n        userScores,\n        shouldReposition,\n        setShouldReposition,\n      }}\n    >\n      {children}\n    </WebSocketContext.Provider>\n  );\n};\n\nexport const useWebSocket = () => {\n  const context = useContext(WebSocketContext);\n  if (!context)\n    throw new Error(\"useWebSocket must be used within a WebSocketProvider\");\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}